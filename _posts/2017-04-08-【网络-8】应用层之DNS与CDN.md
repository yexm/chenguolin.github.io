---
layout:  post    # 使用的布局（不需要改）
catalog: true   # 是否归档
author: 陈国林 # 作者
tags:         #标签
    - 网络
---

# 一. DNS
`DNS`中文名称`域名解析系统`，计算机网络中大部分的通信采用的TCP/IP，因此计算机需要智能识别IP地址。由于IP地址不便于记忆，因此发明了域名解析系统，用于把一个域名解析为具体的IP地址。

![](https://github.com/chenguolin/chenguolin.github.io/blob/master/data/image/dns-root.png?raw=true)

1. 根域：`.`  (根域名服务器(全球有13个根域名服务): 返回顶级域 DNS 服务器的 IP 地址)
2. 顶级域：`.com`   （顶级域名服务器: 返回权威 DNS 服务器的 IP 地址）
3. 二级域：`baidu.com` （权威域名服务器(某公司、组织负责): 返回解析结果）
4. 子域名：`www.baidu.com`

DNS解析过程如下，例如我们访问 google.com 的域名解析过程如下，主机->本地DNS服务器是`递归查询`，本地DNS服务器->各级DNS服务器是`迭代查询`。所以，我们一般也称本地DNS服务器为递归服务器。
![](https://github.com/chenguolin/chenguolin.github.io/blob/master/data/image/dns-trace.png?raw=true)

```
1. 访问 www.googole.com
2. 先检查主机 hosts 文件中是否存在 www.googole.com 对应的解析记录，有直接返回
3. 继续检查主机 DNS 缓存中是否存在 www.googole.com 对应的解析记录，有直接返回  (https://www.linuxjournal.com/content/localhost-dns-cache)
4. 向本地 DNS 服务器 发起 DNS 查询请求
5. 路由器接收到 DNS 查询请求后，检查路由器 DNS 缓存，有直接返回
6. 路由器向本地 DNS 服务器 发起 DNS 查询请求
7. 本地 DNS 服务器 接收到 DNS 查询请求后，发现自己不是权威 DNS ，且无对应的缓存数据，于是开始进行 DNS 迭代查询
8. 本地 DNS 服务器 将请求发送给 根域名服务器，根域名服务器 接收到请求后，将 顶级域名服务器 (.com) IP 发送给 本地 DNS 服务器
9. 本地 DNS 服务器 将请求发送给 顶级域名服务器，顶级域名服务器 接收到请求后，将 二级域名服务器 (google.com) IP 发送给 本地 DNS 服务器
10. 本地 DNS 服务器 将请求发送给 二级域名服务器，二级域名服务器 接收到请求后，发现自己是 www.google.com域名的 权威 DNS 服务器，于是将 www.google.com 解析的 IP 发送给 本地 DNS 服务器
11. 本地 DNS 服务器 接收到解析结果后，将 IP 原路返回，最终到达主机
12. 主机 接收到 www.google.com 解析结果，根据 IP 与 www.google.com 建立 TCP 连接，然后发起 HTTP 请求
13. 剩下的就是常规的HTTP请求的交互过程
```

DNS解析有2种方式
1. `递归查询`: 递归查询的DNS会替发起请求的用户客户端完成一系列的DNS查询，直到获取了最终结果后，返回给查询客户端。大多数Client向Local DNS服务器请求解析采用这种方式。
2. `迭代查询`: 迭代查询各级DNS都把自己知道的信息反馈给客户端，所有的查询过程都由发起请求的客户端自己完成。大多数Local DNS服务器向其他DNS服务器请求解析采用这种方式。

DNS 服务器根据作用可以分为以下几种类型
1. `本地 DNS`: 位于公网中，一般是运营商提供的DNS服务器，位于公司、小区等
2. `内部 DNS`: 位于内网中，提供内网DNS服务也具备DNS缓存与转发能力
3. `外部 DNS`: 位于公网中，提供公网DNS服务，包括DNS解析、缓存与转发
4. `缓存 DNS`: 通过向其他域名服务器查询获得域名->IP地址记录，将域名查询结果缓存到本地，提高重复查询时的速度，本地不设置DNS信息
5. `转发 DNS`: 转发服务器接受查询请求，但并不直接提供DNS解析，而是将所有查询请求发送至另外的DNS服务器，查询结果返回后保存至缓存
6. `权威 DNS`: 负责某个域名的DNS解析
7. `非权威 DNS`: 不负责某个域名的DNS解析，但存在对应缓存查询结果

DNS 还可以做 `全局负载均衡`: 为了保证我们的应用高可用，往往会部署在多个机房，每个地方都会有自己的 IP 地址。当用户访问某个域名的时候，这个 IP 地址可以轮询访问多个数据中心。如果一个数据中心因为某种原因挂了，只要在 DNS 服务器里面，将这个数据中心对应的 IP 地址删除，就可以实现一定的高可用。对于简单的应用来说，通过把域名解析为一个或多个IP地址，通过Round-Robin算法就可以实现简单的负载均衡。

通过上面的示例过程我们知道，域名解析过程涉及到好几个环节，因此存在不少问题。

1. `缓存问题`: 客户端发起域名解析的整个请求过程中涉及到好几个环节，为了保证请求的时效性，会对域名结果做缓存。例如 本地DNS服务器 不会每次DNS解析都去请求根域名服务器，而是会在服务器内部做缓存。引入缓存，必然会带来不一致问题，也就是说可能会导致域名解析结果不对。
2. `缓存TTL`: 本地 DNS 服务器是由不同地区、不同运营商独立部署的。对域名解析缓存的处理上，实现策略也有区别，有的会忽略域名解析结果的 TTL 时间限制，在权威 DNS 服务器解析变更的时候，导致解析结果在全网生效的周期非常漫长。
3. `解析延迟`: 域名解析过程需要递归遍历多个 DNS 服务器，才能获得最终的解析结果，这会带来一定的时延，甚至会解析超时。

# 二. CDN
权威 DNS 发现一个域名解析结果有多个 IP 时，正常情况下会使用 IP 轮询的方式来将 IP 平均分配给多个 DNS 请求，从而达到负载均衡的效果。由于 IP 轮询时平均分配，不能根据不同服务器的负载情况优化分配，如果有一台服务器宕机了，DNS 不能及时了解到该情况把该服务器的 IP 分配出去，会造成无法访问。因此，在权威 DNS 和 服务器之间加上一个 CDN 层就显得很必要了，CDN 内部通过智能DNS调度实现全局负载均衡。

`CDN` 中文名称为内容分发网络，用来解决不同地域的用户访问网站速度慢问题，通过缓存各种静态文件（css／html／图片等）达到速度优化的目的，核心是`智能DNS调度`。

`域名使用CDN加速之后，最大区别在于本地DNS服务器拿到的解析结果不再是一个IP地址，而是返回一个 cname，并告诉本地DNS服务器去请求CDN厂商的GSLB进行解析，请求到了CDN厂商GSLB之后，会根据本地DNS服务器的IP、运营商等情况返回最靠近用户、网络最通畅的 CDN 节点IP，本地DNS服务器拿这个IP再返回给端。`

![](https://github.com/chenguolin/chenguolin.github.io/blob/master/data/image/dns-cdn.png?raw=true)

1. 离用户最近的节点称为`边缘节点`
2. A记录指域名解析得到的一个IP地址 (IPV4)
3. CNAME指域名解析到另一个域名

整个CDN系统最核心的部分是 智能DNS调度 英文名为GSLB，目前有以下几个实现方式

1. `基于DNS的GSLB`: 通过本地DNS的所属区域，利用DNS解析给用户返回该区域的边缘节点IP列表，但是存在本地DNS不对导致返回的边缘节点IP不是离用户最近。这种方式无法获取用户IP地址，只能获取到本地DNS的IP地址。
2. `基于HTTP 302的GSLB`: 先通过本地DNS解析获得GSLB的IP地址，用户访问GSLB的时候返回一个HTTP 302的信息，引导用户跳转到最近的边缘节点。这种方式会多一次HTTP请求，流程比较长。

使用CDN之后虽然可以加速访问，但是还是没有解决一个问题，因为无论用与不用CDN我们都是要依赖 本地DNS 服务器，这里面就有个问题 `某些本地 DNS服务器会忽略DNS TTL信息，而采用固定的TTL时间`，对于这种情况其实是无能为力的，只能让运营商去配合改。

# 三. HTTPDNS
`HTTPNDS` 其实就是不走传统的 DNS 解析，而是自己搭建基于 HTTP 协议的 DNS 服务器集群，分布在多个地点和多个运营商。当客户端需要 DNS 解析的时候，直接通过 HTTP 协议进行请求这个服务器集群，得到就近的地址。

默认的域名解析都是走 DNS 的，因而使用 HTTPDNS 需要绕过默认的 DNS 路径，就不能使用默认的客户端。使用 HTTPDNS 的，往往是手机APP，需要在APP嵌入支持 HTTPDNS 的客户端 SDK。由于客户端嵌入了 SDK，就可以知道手机是哪个国家、哪个运营商、哪个省，甚至哪个市，HTTPDNS 服务端可以根据这些信息，选择最佳的服务节点返回。

![](https://github.com/chenguolin/chenguolin.github.io/blob/master/data/image/httpdns.jpg?raw=true)

