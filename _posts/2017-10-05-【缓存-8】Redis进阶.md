---
layout:  post  # 使用的布局（不需要改）
catalog: true  # 是否归档
author: 陈国林 # 作者
tags:          #标签
    - 缓存
---

# 一. Redis系统架构
Redis 组件的系统架构如图所示，主要包括事件处理、数据存储及管理、用于系统扩展的主从复制/集群管理，以及为插件化功能扩展的 Module System 模块。

![](https://github.com/chenguolin/chenguolin.github.io/blob/master/data/image/redis-1.png?raw=true)

1. `事件处理`: Redis 中的事件处理模块，采用的是自研的 ae 事件驱动模型，可以进行高效的网络 IO 读写、命令执行，以及时间事件处理。网络 IO 读写处理采用的是 IO 多路复用技术，通过对 evport、epoll、kqueue、select 等进行封装，同时监听多个 socket，并根据 socket 目前执行的任务，来为 socket 关联不同的事件处理器。Redis 中时间事件比较简单，目前主要是执行定时任务，来做一些统计更新、过期 key 清理、AOF 及 RDB 持久化等辅助操作。

2. `redisDB`: Redis 的内存数据都存在 redisDB 中。Redis 支持多 DB，每个 DB 都对应一个 redisDB 结构。Redis 的 8 种数据类型，每种数据类型都采用一种或多种内部数据结构进行存储。同时这些内部数据结构及数据相关的辅助信息，都以 kye/value 的格式存在 redisDB 中的各个 dict 字典中。

3. `AOF和RDB`: 数据在写入 redisDB 后，这些执行的写指令还会及时追加到 AOF 中，追加的方式是先实时写入AOF 缓冲，然后按策略刷缓冲数据到文件。由于 AOF 记录每个`写`操作，所以一个 key 的大量中间状态也会呈现在 AOF 中，导致 AOF 冗余信息过多，因此 Redis 还设计了一个 RDB 快照操作，可以通过定期将内存里所有的数据快照落地到 RDB 文件，来以最简洁的方式记录 Redis 的所有内存数据。

4. `BIO线程`: Redis 进行数据读写的`核心处理线程是单线程模型`，为了保持整个系统的高性能，必须避免任何会引起内核阻塞的操作。为此，Redis 增加了 BIO 线程，来处理容易导致阻塞的 文件close、fsync 等操作，确保系统处理的性能和稳定性。

5. `Eviction pool`: 在 server 端，内存永远是昂贵且短缺的，Redis 中，过期的 key 需要及时清理，不活跃的 key 在内存不足时也可能需要进行淘汰。为此，Redis 设计了 8 种淘汰策略，借助新引入的 eviction pool，进行高效的 key 淘汰和内存回收。

6. `Master-slave`: Redis 支持主从复制，使用主从复制进行业务数据的读写分离，大幅提升 Redis 系统的稳定读写能力。通过主从复制可以较好的解决 Redis 的单机读写问题，但所有写操作都集中在 master 服务器，很容易达到 Redis 的写上限，同时 Redis 的主从节点都保存了业务的所有数据，随着业务发展，很容易出现内存不够用的问题。为此，Redis 分区无法避免。虽然业界大多采用在 client 和 proxy 端分区`（例如 twemproxy）`，但 Redis 自己也推出了 cluster 功能，并不断进行优化。

7. `Redid clsuter`: Redis cluster 预先设定了 16384 个 slot 槽，在 Redis 集群启动时，通过手动或自动将这些 slot 分配到不同服务节点上。在进行 key 读写定位时，首先对 key 做 hash，并将 hash 值对 16383 ，做`按位与运算 (比取模性能好)`，确认 slot，然后确认服务节点，最后再对 对应的 Redis 节点，进行常规读写。如果 client 发送到错误的 Redis 分片，Redis 会发送重定向回复。如果业务数据大量增加，Redis 集群可以通过数据迁移，来进行在线扩容。

# 二. Redis协议解析和处理
## ① 协议解析
Redis 请求命令进入触发 IO 读事件后，会从连接文件描述符读取请求，并存入`读缓冲`。读缓冲默认是 16KB，读取命令时，如果发现请求超过 1GB，则直接报异常，关闭连接。

读取完请求命令后，则根据读缓冲进行协议解析。协议解析时，首先查看协议的首字符。如果是 *，则解析为字符块数组类型，即 MULTIBULK。否则请求解析为 INLINE 类型。INLINE 类型是以 `\r\n` 结尾的单行字符串，协议命令及参数以空格分隔。协议解析完毕后，将请求参数个数存入 argc 中，将请求的具体参数存入 argv 中。

![](https://github.com/chenguolin/chenguolin.github.io/blob/master/data/image/redis-cmd-1.png?raw=true)

## ② 协议处理
请求命令解析完毕，则进入到协议执行部分。协议执行中，对于 quit 指令，直接返回 OK，设置 flag 为回复后关闭连接。对于非 quit 指令，以 argv[0] 作为命令，从 server 中的命令表中找到对应的 redisCommand。如果没有找到 redisCommand，则返回未知 cmd 异常。如果找到 cmd，则开始执行 redisCommand 中的 proc 函数，进行具体命令的执行。在命令执行完毕后，将响应写入`写缓冲`。并按配置和部署，`将写指令分发给 aof 和 slaves` (持久化和主从同步)。同时更新相关的统计数值。

![](https://github.com/chenguolin/chenguolin.github.io/blob/master/data/image/redis-cmd-2.png?raw=true)

# 三. Redis内部数据结构


